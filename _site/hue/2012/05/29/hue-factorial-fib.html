<!DOCTYPE HTML>
<html>
    <head>
        <link rel="stylesheet" href="/css/pygments.css">
        <title>Factorial and Fib in Hue - Yoncise</title>
    </head>
    <body>
        <header>
    <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/category">Category</a></li>
        <li><a href="/about">About</a></li>
    </ul>
</header>


        <div id="post">
	<h1>Factorial and Fib in Hue</h1>
	<p class="meta">29 May 2012</p>
	<p>As I slowly make progress on my little functional programming language <a href='https://github.com/rsms/hue'>Hue</a>, I&#8217;d just wanted to share the &#8220;Hello World&#8221; of functional programming — <code>factorial</code> and <code>fib</code>.</p>

<p>The <a href='http://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Factorial'>factorial function</a> calculates the factorial of a natural number:</p>

<pre><code>factorial = func (n Int) if n == 0 1 else n * factorial n - 1
factorial 10  # -&gt; 3628800</code></pre>

<p>The <a href='http://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Fibonacci'>fib function</a> computes Fibonacci numbers:</p>

<pre><code>fib = func (n Int)
  if n &lt; 2
    n
  else
    (fib n-1) + fib n-2

fib 32  # -&gt; 2178309</code></pre>

<p>Hue compiles the above functions into very efficient <a href='http://en.wikipedia.org/wiki/Tail_call'>tail calls</a>. The <code>factorial</code> function is even unrolled, eliminating all but one call.</p>

<h2 id='function_result_type_inference_and_multiple_implementations'>Function result type inference and multiple implementations</h2>

<p>Since Hue <a href='https://github.com/rsms/hue/tree/94441d9b31157d712c078faa63c741d78ca3fba2/'>94441d9</a> functions have their result types inferred, as well as the ability to define multiple implementations.</p>

<p>To understand why the ability to provide multiple function implementations is interesting, let&#8217;s define a slightly more versatile <code>factorial</code> function:</p>

<pre><code>factorial = func (n Int) if n == 0 1 else n * factorial n - 1
factorial = func (n Float) if n == 0.0 1.0 else n * factorial n - 1.0</code></pre>

<p>Here, we provide implementations for factorial to operate on both integers and floating point numbers. We can now invoke <code>factorial</code> with both Ints and Floats:</p>

<pre><code>factorial 10    # -&gt; 3628800
factorial 10.0  # -&gt; 3628800.0</code></pre>

<p>Since Hue is strongly typed, simply providing a single implementation would only allow <code>factorial</code> to be available for either integers or floating point numbers (unless we gave the function different names, but that becomes awkward.)</p>

<p>Result type inference is another important hygiene factor.</p>

<p>This basically means that the parser will parse a function&#8217;s body before it finalizes the function&#8217;s result type. Since all functions in Hue return something, we know that whatever is returned is the result value of the function. If there&#8217;s any ambiguity the compiler will complain with an error, avoiding unexpected behavior at runtime.</p>

<p>Consider the following trivial functions:</p>

<pre><code>foo = func (a, b Int) Int a * b * b
bar = func (a, b Float) Float a * a * b</code></pre>

<p>Defining the result type of these functions is <em>redundant</em> and <em>unnecessary</em>, since we can without a doubt say that &#8220;the result type of function F is the type of the value returned&#8221;. As Hue infers the type not only for functions, but for any other non-primary expression (like conditionals), when we after a decent-first reach the surface of an expression (i.e. the last expression of a function body), we will know the type of that expression, thus we can bubble the type upwards.</p>

<pre><code>foo = func (a, b Int) a * b * b
bar = func (a, b Float) a * a * b</code></pre>

<p>As seen here above, we were able to write the same two functions in a more efficient manner.</p>

<p>If a function references itself (i.e. is recursive), Hue will assume the type of the function based on other known types and later update those functions calls when the function&#8217;s result type has been finalized.</p>

<p>Deferring the resolution of a recursive function type is possible since the only case where we are unable to do so, is the case where a recursive function is an infinite loop (which is currently not applicable to anything in Hue.) For instance:</p>

<pre><code>foo = func (n Int) foo n</code></pre>

<p>&#8230;would yield an error when compiled since it defines a function that is guaranteed to crash/block in all eternity. Any recursive function needs some kind of conditional, thus making our stupid <code>foo</code> function a little more useful:</p>

<pre><code>foo = func (n Int) if n &gt; 5 (foo n * n) else n</code></pre>

<p>This will compile, although the program will still crash when <code>foo</code> is given a value higher than 5. That&#8217;s the balance between being helpful and telling you what to do. In this example, the result type of the conditional (the &#8220;if..else&#8221;) is inferred from the one concrete branch (&#8221;n&#8221;), which in turn completes the <code>foo</code> function&#8217;s result type.</p>

<h2 id='tail_recursive_calls_ftw'>Tail recursive calls FTW</h2>

<p>Let&#8217;s get all nerdy and look at the IR produced by Hue for the <code>factorial</code> function example from the beginning of this article:</p>

<pre><code>define i64 @main() nounwind readnone {
  br label %tailrecurse.i

tailrecurse.i:                                    ; preds = %else.i, %0
  %accumulator.tr.i = phi i64 [ 1, %0 ], [ %multmp.i, %else.i ]
  %n.tr.i = phi i64 [ 10, %0 ], [ %subtmp.i, %else.i ]
  %eqtmp.i = icmp eq i64 %n.tr.i, 0
  br i1 %eqtmp.i, label %&quot;hello:factorial$x$x.exit&quot;, label %else.i

else.i:                                           ; preds = %tailrecurse.i
  %subtmp.i = add i64 %n.tr.i, -1
  %multmp.i = mul i64 %accumulator.tr.i, %n.tr.i
  br label %tailrecurse.i

&quot;hello:factorial$x$x.exit&quot;:                       ; preds = %tailrecurse.i
  ret i64 0
}</code></pre>

<p>Note how there&#8217;s actually <em>no function calls</em> involved here. The compiler (mostly thanks to LLVM) were able to optimize the recursive call by unrolling the calls. The above code is very efficient.</p>

<p>Let&#8217;s have look at what Hue does with the <code>fib</code> example function (from earlier in this article):</p>

<pre><code>define i64 @main() nounwind readnone {
  %fib_res = tail call i64 @&quot;hello:fib$x$x&quot;(i64 32)
  ret i64 0
}

define private i64 @&quot;hello:fib$x$x&quot;(i64 %n) nounwind readnone {
  %lttmp = icmp slt i64 %n, 2
  br i1 %lttmp, label %endif, label %else

else:                                             ; preds = %0
  %subtmp = add i64 %n, -1
  %fib_res = tail call i64 @&quot;hello:fib$x$x&quot;(i64 %subtmp)
  %subtmp1 = add i64 %n, -2
  %fib_res2 = tail call i64 @&quot;hello:fib$x$x&quot;(i64 %subtmp1)
  %addtmp = add i64 %fib_res2, %fib_res
  ret i64 %addtmp

endif:                                            ; preds = %0
  ret i64 %n
}</code></pre>

<p>We didn&#8217;t get the royal unroll treatment, but the calls became tail recursive and the true-branch of the conditional expression was short-circuited into the end of the conditional (&#8220;endif&#8221;), saving us a &#8220;PHI&#8221; virtual instruction. This code is also very efficient and has linear time complexity.</p>

<p><a href='https://github.com/rsms/hue'>Hue</a> continues to be my computer programming muse (and TV substitute) as a low intensity hobby project. The intention is to experiment with performant functional programming and to learn stuff, of course. Hue&#8217;s source code is free and open at <a href='https://github.com/rsms/hue'>https://github.com/rsms/hue</a>.</p>

<p>See previous introduction to Hue: <a href='http://rsms.me/2012/05/14/hue.html'>&#8220;Hue — a functional programming language for fun &amp; play&#8221;</a>.</p>
</div>


        
    </body>
</html>
