<!DOCTYPE HTML>
<html>
    <head>
        <link rel="stylesheet" href="/css/pygments.css">
        <title>Move — a programming language - Yoncise</title>
    </head>
    <body>
        <header>
    <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/category">Category</a></li>
        <li><a href="/about">About</a></li>
    </ul>
</header>


        <div id="post">
	<h1>Move — a programming language</h1>
	<p class="meta">02 Mar 2011</p>
	<p>As I&#8217;m very interested in human-computer interaction, programming languages and the act of looking at things from a wider perspective, I decided to design a programming language. First, I scribbled down some key points:</p>

<ul>
<li>
<p>This language should be suitable as a &#8220;first programming language&#8221; for people not previously familiar with programming computers.</p>
</li>

<li>
<p>As low barrier as possible for running it — i.e. it should run on as many platforms as possible needing as few additional tools as possible.</p>
</li>

<li>
<p>Have a simple and limited set of &#8220;words&#8221; (language constructs), hopefully aiding the processes of learning how to write programs.</p>
</li>
</ul>

<p>So I spent a full Sunday two weeks ago punching out a prototype implementation which I was so happy with that I&#8217;ve decided to continue working with this idea and today I finally wrapped everything together with documentation, a guide and throughly tested code.</p>

<p>I call it <a href='http://movelang.org/'>Move</a>. Here is a simple program which print &#8220;Hello John&#8221; three times:</p>

<pre><code>hello = ^(name){ &quot;Hello &quot;+name }
repeat {times: 3} ^{
  print hello {name: &quot;John&quot;}
}</code></pre>

<p>The language is now stable and will probably not change (except for bugs and runtime library expansion) in the near future. JavaScript is normally my &#8220;universal&#8221;, &#8220;go-to&#8221; language for everything from crunching log files and doing simple math to writing small networked programs and web sites. However, during these two weeks I&#8217;ve used Move instead and it just feels right: I get done quicker, less boiler plate code, easier to read, etc.</p>

<p><a href='http://movelang.org/'><img alt='movelangdotorg' src='http://farm6.static.flickr.com/5214/5492500401_54b711ac5e_o.png' /></a></p>

<p>Move <em>compiles down to optimized JavaScript</em> and can run on any ES3 or higher speced JS platform (like a web browser or Node.js). Move also contains a runtime library which not only provides a few carefully crafted functions but also <em>normalizes the JS environment to the ES5 standard</em>, relieving you from feature-testing for &#8220;Object.create&#8221; or doing work-arounds for things like &#8220;Array.isArray&#8221;. Move is open source under a permissive MIT license and available at <a href='https://github.com/rsms/move'>https://github.com/rsms/move</a>.</p>

<h2 id='differences_to_javascript'>Differences to JavaScript</h2>

<p>As mentioned, Move compiles to JavaScript and runs in any ES3 or more modern JavaScript runtime, so comparing Move to JavaScript comes naturally. The first version of Move was actually a superset of JavaScript, allowing pristine JavaScript inside Move. As the language evolved and was simplified, some changes where made (for instance: &#8221;&#94;&#8221; always meaning &#8220;function&#8221; and never meaning &#8220;xor&#8221;, introducing the &#8220;xor&#8221; operator).</p>

<p>Here&#8217;s a summary of the differences between Move and JavaScript:</p>

<ul>
<li>
<p><strong>Functions</strong> are declared using one single expression: <code>^(arg1){...}</code> and can be called using either <strong>keyword arguments</strong> or positional arguments. Functions without arguments can be written as <code>^{...</code> or <code>^(){...</code> (parenthesis are optional).</p>

<ul>
<li>
<p>In JavaScript, there are two different ways to define a function: using the function expression and the function declaration statement, the latter having subtle restrictions. Move only has function expressions and all but strictly anonymous functions are named, providing a richer stack trace when debugging.</p>
</li>

<li>
<p>As functions, or lambdas, are the key awesomeness of JavaScript and is a very light-weight thing, the &#8220;function&#8221; keyword and boilerplate argument parens just need to be easier to write. Move uses the &#8221;&#94;&#8221; keyword and does not enforce <code>()</code> for argument-less functions.</p>
</li>

<li>
<p>The last statement in a function is automatically returned (the &#8220;product&#8221; of calling a function).</p>
</li>

<li>
<p>Functions can be called using the <code>foo {key: value}</code> syntax, passing arguments by name. This greatly increases code readability and eliminates the tedious <code>foo(null, null, null, null, true)</code> style when only one of many arguments are relevant.</p>
</li>

<li>
<p>Functions can be called using the <code>foo value, ...</code> syntax, passing arguments in a simple succession. This feature allows Move to have a very limited set of language keywords and instead implement things like print, repeat, create, etc as regular functions. For instance, this allows for creating DSL-like extensions to the language.</p>
</li>

<li>
<p>When defining functions, any argument can be given a default value using either <code>:</code> or <code>=</code>. E.g. <code>foo = ^(bar, baz: 4, names=[], age) {...</code>.</p>
</li>
</ul>
</li>

<li>
<p><strong>Variables</strong> are implicitly declared &#8211; Move will automatically declare (i.e. &#8220;create and attach&#8221;) a newfound variable in the scope which it first was used. The use of &#8220;var&#8221; produces a syntax error. A variable will only be declared if there&#8217;s no variable with the same name which is reachable from the current scope (this is possible since the Move compiler is AST-aware).</p>
</li>

<li>
<p><strong>No commas</strong> required to terminate expressions. Move will determine when a comma is needed so you don&#8217;t have to (and the code gets more readable).</p>
</li>

<li>
<p>No type-coercing <strong>equality operators</strong> &#8211; in Move, <code>==</code> does not perform type coercion and behaves just like <code>===</code> in JavaScript. Same goes for <code>!=</code>.</p>
</li>

<li>
<p><strong>@-shorthand</strong> for accessing properties of the <code>this</code> object. E.g. <code>this.foo = 5</code> can be written as <code>@foo = 5</code>.</p>
</li>

<li>
<p><strong>Importing</strong> CommonJS modules can be done using the <code>import</code> statement. E.g. rather than the tedious <code>var module1 = require(&quot;module1&quot;)</code> boilerplate, you can write <code>import module1</code></p>
</li>

<li>
<p><strong>Exporting</strong> CommonJS modules is aided by the <code>export</code> statement. E.g. instead of writing <code>var foo = exports.foo = function () {...</code> you can write <code>export foo = ^{...</code> (or even <code>export foo</code> if <code>foo</code> is defined elsewhere).</p>
</li>

<li>
<p>A small runtime library makes Move <strong>ES5 normalized</strong> even in non-ES5 environments. This means less feature probing and less boiler-plate code. Things like <code>Array.isArray</code>, <code>Object.create</code> and <code>String.prototype.trim</code> are all guaranteed to be available and function according to the ES5 standard.</p>
</li>
</ul>

<p>Move is <strong>designed for humans</strong> which is the reason for why things like variable declarations and statement terminators has been removed &#8211; they are simply not part of the essentials or essence of what a programmer should be thinking about. The computer is, or at least should be, better at deciding those things.</p>

<h2 id='function_the_ultimate'>Function the ultimate</h2>

<p>The biggest difference to most other programming languages is how functions are created, handled and invoked. In Move (and JavaScript) functions are light-weight, first class objects which <em>should be used</em>. Writing <code>name = function name(x, y, z) {...</code> quickly becomes a tedious task when whipping up code, so Move simplifies the function expression syntax to <code>name = ^(x, y, z) {...</code>.</p>

<p>An example:</p>

<pre><code>delayed_print = ^(message, delay=1000) {
  after {delay: delay} ^{ print message }
}
delayed_print &quot;Hello&quot;                // &quot;Hello&quot; appears 1 second later</code></pre>

<p>Calling functions with keyword arguments (or &#8220;named&#8221; arguments if you will) greatly increases readability and thus maintainability of code.</p>

<pre><code>delayed_print { message: &quot;Hello&quot;, delay: 5000 }
// &quot;Hello&quot; appears 5 seconds later</code></pre>

<p>Move allows calling function without neither parenthesis nor curly brackets, enabling the use of regular functions to build DSL-like mini-languages. For instance, this program defines a &#8220;repeat&#8221; function which is then called to invoke an anonymous function three times, producing three &#8220;Hello&#8221;:</p>

<pre><code>repeat = ^(times){ ^(block){
  if (times != undefined)
    for (i=0; i&lt;times; ++i) if (block(i) == true) break
  else
    while (true) if (!block()) break
}}

repeat {times: 3} ^{
  print &quot;Hello&quot;
}</code></pre>

<p>This works since the &#8220;repeat&#8221; function produces an anonymous function (which when called invokes another function <em>times</em> number of times) which will be called due the short-hand call style in Move. The invocation above roughly compiles down to the following JavaScript:</p>

<pre><code>repeat({times: 3})(function () {
  print(&quot;Hello&quot;);
});</code></pre>

<p>There are other neat effects of the short-hand call style. For instance, consider the following Move code:</p>

<pre><code>print(JSON.stringify(&quot;1,2,3,4,5,1,4&quot;.split(&quot;,&quot;)))</code></pre>

<p>Which can also be written like this:</p>

<pre><code>print JSON &quot;1,2,3,4,5,1,4&quot;.split &quot;,&quot;</code></pre>

<p>Move comes with a few but carefully crafted built-in functions (which in true Move style can be manipulated or replaced at will):</p>

<ul>
<li><a href='http://movelang.org/#create'><code>create</code></a> — create new objects based on other objects (object-oriented programming using differential inheritance).</li>

<li><a href='http://movelang.org/#extend'><code>extend</code></a> — extend an existing object by shallow-copying properties from another object.</li>

<li><a href='http://movelang.org/#print'><code>print</code></a> — visualize any value.</li>

<li><a href='http://movelang.org/#repeat'><code>repeat</code></a> — repeat something (a friendlier approach to &#8220;for (i = 0; i &lt; &#8230;&#8221; and &#8220;while (&#8230;&#8221;.</li>

<li><a href='http://movelang.org/#after'><code>after</code></a> — perform something after a certain point in time.</li>
</ul>

<p><a href='http://movelang.org/#create'>The &#8220;create&#8221; function</a> is used to create new objects semantically based on other objects, achieving a very straight-forward approach to object-oriented programming:</p>

<pre><code>animal = { type: &quot;an animal&quot;,
           toString: ^{ &quot;I&#39;m &quot; + @type } }
cat = create animal, { type: &quot;furry&quot; }
print &quot;Cat: &quot; + cat  // --&gt; &quot;Cat: I&#39;m furry&quot;</code></pre>

<p>In the above example, &#8220;cat&#8221; inherits from &#8220;animal&#8221; — adding, changing or removing properties on &#8220;animal&#8221; has an effect on what happens when accessing properties of the &#8220;cat&#8221; object.</p>

<p>Read more about <a href='http://en.wikipedia.org/wiki/Prototype-based_programming'>Prototype-based programming</a> and <a href='http://en.wikipedia.org/wiki/Differential_inheritance'>Differential inheritance on Wikipedia&#8230;</a></p>

<h2 id='try_to_move'>Try to Move</h2>

<p>I recommend checking out the <a href='http://movelang.org/'>website at movelang.org</a> (albeit being a work in progress) as well as the interactive console, perfect for playing around with Move, at <a href='http://movelang.org/try/'>movelang.org/try</a>.</p>

<p>For TextMate junkies, there&#8217;s also a Move bundle with syntax highlighting, commands for running programs, displaying compiled JavaScript code, AST viewer, etc. <a href='https://github.com/rsms/move/zipball/master'>Grab a snapshot of @master</a> and find Move.tmbundle in the &#8220;extras&#8221; directory.</p>

<h3 id='installing_move_for_nodejs_using_npm'>Installing Move for Node.js using NPM</h3>

<p>First, you need to have <a href='http://nodejs.org/'>Node.js</a> and <a href='http://npmjs.org/'>NPM</a> installed, then in a terminal:</p>

<pre><code>$ npm install move</code></pre>

<p>You should now have both the Move library (compiler and runtime) installed as well as a &#8220;move&#8221; program which can execute Move scripts.</p>

<pre><code>$ move my-move-program.mv</code></pre>

<p>Or in a Node.js JavaScript file by at one point in time requiring the &#8220;move&#8221; module (which will enable loading of Move code in Node.js):</p>

<pre><code>require(&#39;move&#39;);
require(&#39;./my-move-program&#39;);</code></pre>

<p>Note that you can not embed Move into JavaScript but must separate the code into .mv files.</p>
</div>


        
    </body>
</html>
